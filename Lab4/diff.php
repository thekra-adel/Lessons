<?php
 /*
 الفرق بين PDO, MySQLi:

 ******************* PDO *********************
 - يدعم العديد من قواعد البيانات مثل MySQL و PostgreSQL و SQLite و MSSQL و Oracle وغيرها.
 - يعتمد فقط على أسلوب البرمجة الكائنية (Object-Oriented).
 - يدعم الاستعلامات المحضرة أيضاً، ولكنه يوفر ميزات أمان إضافية مثل دعم المعاملات (transactions) بشكل أكثر مرونة.
 - يدعم المعاملات بشكل عام ويمكن استخدامها مع قواعد بيانات متعددة.
 - اكثر مرونة وقوة ولكن يتطلب مهارات برمجية أعلى قليلاً بسبب اعتماده على البرمجة الكائنية.
 - يوفر واجهات أكثر عمومية ومتوافقة مع مختلف قواعد البيانات، مثل fetch() و fetchAll().
 - يوفر خيارات أفضل لإدارة الأخطاء من خلال استثناءات (Exceptions).
 - يمكن أن يكون أبطأ قليلاً في بعض الحالات بسبب أنه يدعم العديد من قواعد البيانات وليس فقط MySQL.
 - يُستخدم بشكل شائع في أطر العمل (Frameworks) مثل Laravel و Symfony بفضل مرونته ودعمه للعديد من قواعد البيانات.
 - يقدم طريقة أكثر مرونة وأمانًا للتعامل مع الأنواع المختلفة من البيانات. باستخدام PDO::PARAM_STR أو PDO::PARAM_INT، يمكن تحديد نوع البيانات بشكل آمن قبل الإرسال إلى الاستعلام.


 ******************** MySQLi *********************
 - يدعم MySQL فقط.
 - يدعم أسلوب البرمجة الإجرائية (Procedural) و أسلوب البرمجة الكائنية (Object-Oriented).
 - يوفر الدعم للاستعلامات المحضرة (Prepared Statements) التي تساعد في الوقاية من هجمات SQL Injection.
 - يدعم المعاملات في MySQL فقط.
 - قد يكون أسهل بعض الشيء للمبتدئين لأنه يدعم أسلوب البرمجة الإجرائية، الذي يعتبر أبسط في البداية
 - يحتوي على وظائف خاصة بـ MySQL، مثل mysqli_fetch_assoc() و mysqli_fetch_row()، التي قد تكون مريحة في بعض الحالات عند التعامل مع MySQL فقط.
 - يمكن التعامل مع الأخطاء باستخدام أسلوب الكائنات أو أسلوب الإجرائي.
 - يمكن أن يكون أكثر كفاءة في التفاعل مع MySQL، خاصة إذا كنت تستخدم أسلوب البرمجة الإجرائية. لكنه مخصص لـ MySQL فقط.
 -غالباً ما يستخدم في مشاريع صغيرة أو مشاريع تعتمد فقط على MySQL.
 -يدعم العديد من أنواع البيانات بشكل جيد، لكن التعامل مع البيانات الكبيرة قد يتطلب بعض المهارات الخاصة في التعامل مع دوال معينة.
 
 */
?>